"""
Coherence Field Theory (CFT) Neural Simulator - Python Implementation
=====================================================================

Exact implementation of the symbolic coherence field equation:
∂²θ/∂t² = (1/β)[∇·(γ∇θ - α∇θ/(|∇θ|²+ε²)^(3/2)) + V'(θ)]

Energy functional:
E = (β/2)(∂θ/∂t)² + α/√(|∇θ|²+ε²) + (γ/2)|∇θ|² + V(θ)

Run each cell sequentially in Jupyter notebook for interactive CFT simulation.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.widgets import Slider, Button
from IPython.display import HTML
import time

class CoherenceFieldSimulator:
    """
    Coherence Field Theory simulator implementing exact CFT equations
    for neural phase field dynamics with energy conservation.
    """
    
    def __init__(self, width=100, height=80, dx=0.2, dt=0.01):
        """
        Initialize CFT simulator with grid dimensions and parameters.
        
        Parameters:
        -----------
        width, height : int
            Grid dimensions
        dx : float
            Spatial resolution
        dt : float
            Time step
        """
        self.width = width
        self.height = height
        self.dx = dx
        self.dt = dt
        
        # CFT Parameters
        self.alpha = 1.2    # Coherence potential strength
        self.beta = 0.8     # Inertial resistance/damping
        self.gamma = 0.4    # Spatial coupling strength
        self.epsilon = 0.05 # Regularization parameter
        
        # Initialize field arrays
        self.theta = np.zeros((height, width))
        self.theta_dot = np.zeros((height, width))
        self.theta_ddot = np.zeros((height, width))
        
        # Derived field quantities
        self.grad_x = np.zeros((height, width))
        self.grad_y = np.zeros((height, width))
        self.grad_mag = np.zeros((height, width))
        self.coherence_potential = np.zeros((height, width))
        self.local_energy = np.zeros((height, width))
        
        # System metrics
        self.total_energy = 0.0
        self.total_coherence = 0.0
        self.max_coherence = 0.0
        self.energy_history = []
        
        # Coordinate grids
        self.x_coords = np.linspace(-self.width*dx/2, self.width*dx/2, width)
        self.y_coords = np.linspace(-self.height*dx/2, self.height*dx/2, height)
        self.X, self.Y = np.meshgrid(self.x_coords, self.y_coords)
    
    def symbolic_potential(self, theta):
        """Symbolic potential V(θ) - adjustable preference landscape"""
        return 0.1 * (1 - np.cos(2 * theta)) + 0.05 * theta**2
    
    def symbolic_potential_derivative(self, theta):
        """Derivative of symbolic potential V'(θ)"""
        return 0.2 * np.sin(2 * theta) + 0.1 * theta
    
    def initialize_field(self, pattern='coherent_domains'):
        """
        Initialize field with various patterns representing different neural states.
        
        Parameters:
        -----------
        pattern : str
            Pattern type: 'coherent_domains', 'traveling_wave', 'memory_formation', 
                         'attention_focus', 'random_noise'
        """
        if pattern == 'coherent_domains':
            # Multiple coherent regions (like cortical columns)
            d1 = np.sqrt((self.X - 2)**2 + (self.Y - 1)**2)
            d2 = np.sqrt((self.X + 1.5)**2 + (self.Y + 1.2)**2)
            d3 = np.sqrt((self.X - 1)**2 + (self.Y - 2)**2)
            self.theta = 1.5*np.exp(-d1**2/0.5) - 1.2*np.exp(-d2**2/0.3) + 0.8*np.exp(-d3**2/0.7)
            self.theta_dot.fill(0)
            
        elif pattern == 'traveling_wave':
            # Neural traveling wave initialization
            self.theta = 0.8 * np.sin(0.5 * self.X) * np.exp(-0.1 * self.Y**2)
            self.theta_dot = 0.3 * np.cos(0.5 * self.X) * np.exp(-0.1 * self.Y**2)
            
        elif pattern == 'memory_formation':
            # Simulate memory encoding with competing patterns
            memory1 = np.exp(-((self.X - 1.5)**2 + self.Y**2)/0.8)
            memory2 = np.exp(-((self.X + 1.5)**2 + self.Y**2)/0.6)
            noise = 0.1 * (np.random.random((self.height, self.width)) - 0.5)
            self.theta = memory1 - 0.7*memory2 + noise
            self.theta_dot.fill(0)
            
        elif pattern == 'attention_focus':
            # Single strong coherent region (attention spotlight)
            attention_d = np.sqrt(self.X**2 + self.Y**2)
            self.theta = 2.0 * np.exp(-attention_d**2/0.4)
            self.theta_dot.fill(0)
            
        elif pattern == 'random_noise':
            self.theta = 0.3 * (np.random.random((self.height, self.width)) - 0.5)
            self.theta_dot.fill(0)
        
        else:
            self.theta.fill(0)
            self.theta_dot.fill(0)
        
        self.theta_ddot.fill(0)
        self.energy_history = []
    
    def compute_gradients(self):
        """Compute spatial gradients using central differences with periodic boundaries"""
        # Periodic boundary conditions using numpy roll
        # Roll shifts the array: -1 means shift left (to get right neighbor)
        theta_right = np.roll(self.theta, -1, axis=1)  # Shift columns left
        theta_left = np.roll(self.theta, 1, axis=1)    # Shift columns right  
        theta_up = np.roll(self.theta, -1, axis=0)     # Shift rows up
        theta_down = np.roll(self.theta, 1, axis=0)    # Shift rows down
        
        # Central difference gradients
        self.grad_x = (theta_right - theta_left) / (2.0 * self.dx)
        self.grad_y = (theta_up - theta_down) / (2.0 * self.dx)
        self.grad_mag = np.sqrt(self.grad_x**2 + self.grad_y**2)
        
        # Coherence potential: α/√(|∇θ|² + ε²)
        denominator = np.sqrt(self.grad_mag**2 + self.epsilon**2)
        self.coherence_potential = self.alpha / denominator
    
    def compute_coherence_divergence(self):
        """
        Compute divergence of the coherence field:
        ∇·(γ∇θ - α∇θ/(|∇θ|²+ε²)^(3/2))
        """
        # Coherence field components
        grad_mag_sq_reg = self.grad_mag**2 + self.epsilon**2
        coherence_factor = self.alpha / (grad_mag_sq_reg**(1.5))
        
        field_x = self.gamma * self.grad_x - coherence_factor * self.grad_x
        field_y = self.gamma * self.grad_y - coherence_factor * self.grad_y
        
        # Compute divergence using central differences with periodic boundaries
        field_x_right = np.roll(field_x, -1, axis=1)
        field_x_left = np.roll(field_x, 1, axis=1)
        field_y_up = np.roll(field_y, -1, axis=0)
        field_y_down = np.roll(field_y, 1, axis=0)
        
        div_x = (field_x_right - field_x_left) / (2.0 * self.dx)
        div_y = (field_y_up - field_y_down) / (2.0 * self.dx)
        
        return div_x + div_y
    
    def evolve_field(self):
        """
        Main evolution step using exact CFT equations:
        ∂²θ/∂t² = (1/β)[∇·(γ∇θ - α∇θ/(|∇θ|²+ε²)^(3/2)) + V'(θ)]
        """
        # Compute all gradients
        self.compute_gradients()
        
        # Compute accelerations using the full CFT equation
        coherence_divergence = self.compute_coherence_divergence()
        potential_force = -self.symbolic_potential_derivative(self.theta)
        
        self.theta_ddot = (coherence_divergence + potential_force) / self.beta
        
        # Update velocities and positions (Verlet integration)
        self.theta_dot += self.dt * self.theta_ddot
        self.theta += self.dt * self.theta_dot
        
        # Compute energy and coherence metrics
        self.compute_energy_and_coherence()
    
    def compute_energy_and_coherence(self):
        """
        Compute total energy according to CFT energy functional:
        E = (β/2)(∂θ/∂t)² + α/√(|∇θ|²+ε²) + (γ/2)|∇θ|² + V(θ)
        """
        kinetic_energy = 0.5 * self.beta * self.theta_dot**2
        coherence_energy = self.coherence_potential
        gradient_energy = 0.5 * self.gamma * self.grad_mag**2
        potential_energy = self.symbolic_potential(self.theta)
        
        self.local_energy = kinetic_energy + coherence_energy + gradient_energy + potential_energy
        self.total_energy = np.sum(self.local_energy)
        
        # Coherence measure: high when gradients are small
        coherence = 1.0 / (1.0 + self.grad_mag * 10)
        self.total_coherence = np.mean(coherence)
        self.max_coherence = np.max(coherence)
        
        # Track energy history for conservation verification
        self.energy_history.append(self.total_energy)
        if len(self.energy_history) > 500:
            self.energy_history.pop(0)
    
    def simulate_steps(self, n_steps):
        """Run simulation for n steps"""
        for _ in range(n_steps):
            self.evolve_field()

# ===================================================================
# VISUALIZATION AND INTERACTIVE COMPONENTS
# ===================================================================

def create_cft_visualization(sim):
    """Create comprehensive CFT visualization with multiple views"""
    
    fig = plt.figure(figsize=(16, 12))
    
    # Main phase field plot
    ax1 = plt.subplot(2, 3, (1, 2))
    im1 = ax1.imshow(sim.theta, extent=[sim.x_coords[0], sim.x_coords[-1], 
                                       sim.y_coords[0], sim.y_coords[-1]], 
                     cmap='RdBu_r', origin='lower', interpolation='bilinear')
    ax1.set_title('Neural Phase Field θ(x,t)', fontsize=14, fontweight='bold')
    ax1.set_xlabel('x')
    ax1.set_ylabel('y')
    plt.colorbar(im1, ax=ax1, fraction=0.046, pad=0.04)
    
    # Coherence potential plot
    ax2 = plt.subplot(2, 3, 3)
    im2 = ax2.imshow(sim.coherence_potential, extent=[sim.x_coords[0], sim.x_coords[-1], 
                                                     sim.y_coords[0], sim.y_coords[-1]], 
                     cmap='Greens', origin='lower', interpolation='bilinear')
    ax2.set_title('Coherence Wells', fontsize=12, fontweight='bold')
    ax2.set_xlabel('x')
    ax2.set_ylabel('y')
    plt.colorbar(im2, ax=ax2, fraction=0.046, pad=0.04)
    
    # Energy density plot
    ax3 = plt.subplot(2, 3, 4)
    im3 = ax3.imshow(sim.local_energy, extent=[sim.x_coords[0], sim.x_coords[-1], 
                                              sim.y_coords[0], sim.y_coords[-1]], 
                     cmap='plasma', origin='lower', interpolation='bilinear')
    ax3.set_title('Local Energy Density', fontsize=12, fontweight='bold')
    ax3.set_xlabel('x')
    ax3.set_ylabel('y')
    plt.colorbar(im3, ax=ax3, fraction=0.046, pad=0.04)
    
    # Energy conservation tracking
    ax4 = plt.subplot(2, 3, 5)
    if len(sim.energy_history) > 1:
        ax4.plot(sim.energy_history, 'g-', linewidth=2)
        ax4.set_title('Energy Conservation', fontsize=12, fontweight='bold')
        ax4.set_xlabel('Time Steps')
        ax4.set_ylabel('Total Energy E')
        ax4.grid(True, alpha=0.3)
    
    # Metrics display
    ax5 = plt.subplot(2, 3, 6)
    ax5.axis('off')
    metrics_text = f"""
CFT System Metrics

Total Energy: {sim.total_energy:.3f}
Avg Coherence: {sim.total_coherence:.4f}
Max Coherence: {sim.max_coherence:.4f}

Parameters:
α (coherence): {sim.alpha:.2f}
β (inertia): {sim.beta:.2f}
γ (coupling): {sim.gamma:.2f}
ε (regularization): {sim.epsilon:.3f}

CFT Equation:
∂²θ/∂t² = (1/β)[∇·F + V'(θ)]
F = γ∇θ - α∇θ/(|∇θ|²+ε²)^(3/2)
"""
    ax5.text(0.05, 0.95, metrics_text, transform=ax5.transAxes, fontsize=10,
             verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
    
    plt.tight_layout()
    return fig, (ax1, ax2, ax3, ax4, ax5), (im1, im2, im3)

def create_interactive_cft_demo():
    """Create interactive CFT demonstration with parameter controls"""
    
    # Initialize simulator
    sim = CoherenceFieldSimulator(width=80, height=60)
    sim.initialize_field('coherent_domains')
    sim.compute_gradients()
    sim.compute_energy_and_coherence()
    
    # Create figure with parameter controls
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    plt.subplots_adjust(bottom=0.25)
    
    # Phase field
    ax_phase = axes[0, 0]
    im_phase = ax_phase.imshow(sim.theta, cmap='RdBu_r', origin='lower', interpolation='bilinear')
    ax_phase.set_title('Neural Phase Field θ(x,t)')
    
    # Coherence field
    ax_coherence = axes[0, 1]
    im_coherence = ax_coherence.imshow(sim.coherence_potential, cmap='Greens', origin='lower', interpolation='bilinear')
    ax_coherence.set_title('Coherence Wells')
    
    # Energy tracking
    ax_energy = axes[1, 0]
    line_energy, = ax_energy.plot([], [], 'g-', linewidth=2)
    ax_energy.set_title('Energy Conservation')
    ax_energy.set_xlabel('Time Steps')
    ax_energy.set_ylabel('Total Energy')
    ax_energy.grid(True, alpha=0.3)
    
    # Gradient magnitude
    ax_grad = axes[1, 1]
    im_grad = ax_grad.imshow(sim.grad_mag, cmap='viridis', origin='lower', interpolation='bilinear')
    ax_grad.set_title('Gradient Magnitude |∇θ|')
    
    # Parameter sliders
    ax_alpha = plt.axes([0.1, 0.15, 0.3, 0.03])
    ax_beta = plt.axes([0.1, 0.11, 0.3, 0.03])
    ax_gamma = plt.axes([0.1, 0.07, 0.3, 0.03])
    ax_epsilon = plt.axes([0.1, 0.03, 0.3, 0.03])
    
    slider_alpha = Slider(ax_alpha, 'α (coherence)', 0.1, 3.0, valinit=sim.alpha)
    slider_beta = Slider(ax_beta, 'β (inertia)', 0.1, 2.0, valinit=sim.beta)
    slider_gamma = Slider(ax_gamma, 'γ (coupling)', 0.1, 1.0, valinit=sim.gamma)
    slider_epsilon = Slider(ax_epsilon, 'ε (regularization)', 0.01, 0.2, valinit=sim.epsilon)
    
    # Pattern buttons
    ax_btn1 = plt.axes([0.5, 0.15, 0.12, 0.04])
    ax_btn2 = plt.axes([0.5, 0.10, 0.12, 0.04])
    ax_btn3 = plt.axes([0.5, 0.05, 0.12, 0.04])
    ax_btn4 = plt.axes([0.65, 0.15, 0.12, 0.04])
    ax_btn5 = plt.axes([0.65, 0.10, 0.12, 0.04])
    ax_btn_run = plt.axes([0.8, 0.15, 0.08, 0.04])
    
    btn_domains = Button(ax_btn1, 'Domains')
    btn_wave = Button(ax_btn2, 'Wave')
    btn_memory = Button(ax_btn3, 'Memory')
    btn_attention = Button(ax_btn4, 'Attention')
    btn_noise = Button(ax_btn5, 'Noise')
    btn_run = Button(ax_btn_run, 'Run CFT')
    
    def update_parameters(val):
        sim.alpha = slider_alpha.val
        sim.beta = slider_beta.val
        sim.gamma = slider_gamma.val
        sim.epsilon = slider_epsilon.val
        
        # Recompute with new parameters
        sim.compute_gradients()
        sim.compute_energy_and_coherence()
        update_display()
    
    def update_display():
        # Update images
        im_phase.set_array(sim.theta)
        im_phase.set_clim(vmin=sim.theta.min(), vmax=sim.theta.max())
        
        im_coherence.set_array(sim.coherence_potential)
        im_coherence.set_clim(vmin=sim.coherence_potential.min(), vmax=sim.coherence_potential.max())
        
        im_grad.set_array(sim.grad_mag)
        im_grad.set_clim(vmin=sim.grad_mag.min(), vmax=sim.grad_mag.max())
        
        # Update energy plot
        if len(sim.energy_history) > 1:
            line_energy.set_data(range(len(sim.energy_history)), sim.energy_history)
            ax_energy.set_xlim(0, len(sim.energy_history))
            ax_energy.set_ylim(min(sim.energy_history), max(sim.energy_history))
        
        fig.canvas.draw_idle()
    
    def init_pattern(pattern_name):
        def init_func(event):
            sim.initialize_field(pattern_name)
            sim.compute_gradients()
            sim.compute_energy_and_coherence()
            update_display()
        return init_func
    
    def run_simulation(event):
        for _ in range(50):  # Run 50 steps
            sim.evolve_field()
        update_display()
    
    # Connect callbacks
    slider_alpha.on_changed(update_parameters)
    slider_beta.on_changed(update_parameters)
    slider_gamma.on_changed(update_parameters)
    slider_epsilon.on_changed(update_parameters)
    
    btn_domains.on_clicked(init_pattern('coherent_domains'))
    btn_wave.on_clicked(init_pattern('traveling_wave'))
    btn_memory.on_clicked(init_pattern('memory_formation'))
    btn_attention.on_clicked(init_pattern('attention_focus'))
    btn_noise.on_clicked(init_pattern('random_noise'))
    btn_run.on_clicked(run_simulation)
    
    # Initial display
    update_display()
    
    return sim, fig

# ===================================================================
# USAGE EXAMPLES AND DEMONSTRATIONS
# ===================================================================

def demonstrate_cft_features():
    """Demonstrate key CFT features with different scenarios"""
    
    scenarios = [
        ('coherent_domains', 'Cortical Attention Domains'),
        ('traveling_wave', 'Neural Information Propagation'),
        ('memory_formation', 'Memory Encoding Competition'),
        ('attention_focus', 'Focused Attention State')
    ]
    
    fig, axes = plt.subplots(2, 4, figsize=(20, 10))
    
    for i, (pattern, title) in enumerate(scenarios):
        sim = CoherenceFieldSimulator(width=60, height=50)
        sim.initialize_field(pattern)
        
        # Run simulation
        for _ in range(100):
            sim.evolve_field()
        
        # Plot initial and final states
        row = i // 2
        col = (i % 2) * 2
        
        # Initial state (reset and show)
        sim.initialize_field(pattern)
        sim.compute_gradients()
        sim.compute_energy_and_coherence()
        
        axes[row, col].imshow(sim.theta, cmap='RdBu_r', origin='lower')
        axes[row, col].set_title(f'{title} - Initial')
        axes[row, col].axis('off')
        
        # Final state after evolution
        for _ in range(100):
            sim.evolve_field()
            
        axes[row, col+1].imshow(sim.theta, cmap='RdBu_r', origin='lower')
        axes[row, col+1].set_title(f'{title} - After 100 Steps')
        axes[row, col+1].axis('off')
    
    plt.tight_layout()
    plt.suptitle('CFT Neural Dynamics: Before vs After Evolution', fontsize=16, y=1.02)
    return fig

# ===================================================================
# ANALYSIS TOOLS
# ===================================================================

def analyze_energy_conservation(sim, n_steps=1000):
    """Analyze energy conservation properties of the CFT system"""
    
    initial_energy = sim.total_energy
    energies = []
    
    for step in range(n_steps):
        sim.evolve_field()
        energies.append(sim.total_energy)
        
        if step % 100 == 0:
            print(f"Step {step}: Energy = {sim.total_energy:.6f}, "
                  f"ΔE = {sim.total_energy - initial_energy:.8f}")
    
    energies = np.array(energies)
    energy_drift = np.abs(energies - initial_energy)
    
    plt.figure(figsize=(12, 8))
    
    plt.subplot(2, 2, 1)
    plt.plot(energies)
    plt.title('Total Energy Evolution')
    plt.xlabel('Time Steps')
    plt.ylabel('Energy')
    plt.grid(True, alpha=0.3)
    
    plt.subplot(2, 2, 2)
    plt.semilogy(energy_drift)
    plt.title('Energy Conservation (Log Scale)')
    plt.xlabel('Time Steps')
    plt.ylabel('|ΔE|')
    plt.grid(True, alpha=0.3)
    
    plt.subplot(2, 2, 3)
    plt.imshow(sim.theta, cmap='RdBu_r', origin='lower')
    plt.title('Final θ Field')
    plt.colorbar()
    
    plt.subplot(2, 2, 4)
    plt.imshow(sim.coherence_potential, cmap='Greens', origin='lower')
    plt.title('Final Coherence Wells')
    plt.colorbar()
    
    plt.tight_layout()
    
    print(f"\nEnergy Conservation Analysis:")
    print(f"Initial Energy: {initial_energy:.6f}")
    print(f"Final Energy: {energies[-1]:.6f}")
    print(f"Total Drift: {energies[-1] - initial_energy:.8f}")
    print(f"Relative Drift: {abs(energies[-1] - initial_energy)/initial_energy:.2e}")
    print(f"Max Fluctuation: {np.max(energy_drift):.8f}")

# ===================================================================
# SIMPLE TEST TO VERIFY INSTALLATION
# ===================================================================

def test_cft_basic():
    """Simple test to verify CFT simulator works correctly"""
    print("Testing CFT simulator...")
    
    try:
        # Create simulator
        sim = CoherenceFieldSimulator(width=20, height=20)
        print("✓ Simulator created successfully")
        
        # Initialize field
        sim.initialize_field('attention_focus')
        print("✓ Field initialized successfully")
        
        # Test gradient computation
        sim.compute_gradients()
        print("✓ Gradients computed successfully")
        print(f"  Grad range: {sim.grad_mag.min():.4f} to {sim.grad_mag.max():.4f}")
        
        # Test evolution
        sim.evolve_field()
        print("✓ Field evolution successful")
        print(f"  Energy: {sim.total_energy:.4f}")
        print(f"  Coherence: {sim.total_coherence:.4f}")
        
        # Test multiple steps
        for i in range(5):
            sim.evolve_field()
        print("✓ Multiple evolution steps successful")
        print(f"  Final energy: {sim.total_energy:.4f}")
        
        return sim
        
    except Exception as e:
        print(f"✗ Error: {e}")
        import traceback
        traceback.print_exc()
        return None

# ===================================================================
# MAIN EXECUTION
# ===================================================================

if __name__ == "__main__":
    print("🧠 Coherence Field Theory (CFT) Neural Simulator")
    print("=" * 55)
    print()
    
    # Run basic test first
    sim = test_cft_basic()
    
    if sim is not None:
        print("\n" + "="*55)
        print("Available functions:")
        print("1. create_interactive_cft_demo() - Interactive parameter exploration")
        print("2. demonstrate_cft_features() - Show different neural scenarios")
        print("3. analyze_energy_conservation(sim) - Test energy conservation")
        print()
        print("Quick start:")
        print("sim = CoherenceFieldSimulator()")
        print("sim.initialize_field('coherent_domains')")
        print("fig, axes, ims = create_cft_visualization(sim)")
        print("plt.show()")
        print()
        print("For interactive demo:")
        print("sim, fig = create_interactive_cft_demo()")
        print("plt.show()")

# ===================================================================
# ADVANCED CFT ANALYSIS AND NEUROSCIENCE TESTS
# ===================================================================

def advanced_cft_phase_transition_analysis():
    """
    Analyze phase transitions in CFT parameter space.
    This reveals critical points where coherence wells form/collapse.
    """
    print("🔬 Advanced Analysis: CFT Phase Transitions")
    print("=" * 50)
    
    # Parameter sweeps
    alpha_range = np.linspace(0.1, 3.0, 15)
    beta_range = np.linspace(0.2, 2.0, 10)
    
    # Metrics to track
    coherence_map = np.zeros((len(beta_range), len(alpha_range)))
    stability_map = np.zeros((len(beta_range), len(alpha_range)))
    energy_variance_map = np.zeros((len(beta_range), len(alpha_range)))
    
    print("Running parameter sweep...")
    
    for i, beta in enumerate(beta_range):
        for j, alpha in enumerate(alpha_range):
            # Create simulator with specific parameters
            sim = CoherenceFieldSimulator(width=40, height=40)
            sim.alpha = alpha
            sim.beta = beta
            sim.gamma = 0.4
            sim.epsilon = 0.05
            
            # Initialize with coherent domains
            sim.initialize_field('coherent_domains')
            
            # Run simulation and track stability
            energies = []
            coherences = []
            
            for step in range(200):
                sim.evolve_field()
                energies.append(sim.total_energy)
                coherences.append(sim.total_coherence)
            
            # Compute metrics
            coherence_map[i, j] = np.mean(coherences[-50:])  # Final coherence
            energy_variance_map[i, j] = np.var(energies[-50:])  # Energy stability
            
            # Stability: measure how much field changes in final steps
            final_states = []
            for step in range(20):
                sim.evolve_field()
                final_states.append(np.var(sim.theta))
            stability_map[i, j] = np.mean(final_states)
            
            if (i * len(alpha_range) + j) % 20 == 0:
                print(f"  Progress: {((i * len(alpha_range) + j) / (len(beta_range) * len(alpha_range)) * 100):.0f}%")
    
    # Create phase diagram
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    
    # Coherence phase diagram
    im1 = axes[0].imshow(coherence_map, extent=[alpha_range[0], alpha_range[-1], 
                                               beta_range[0], beta_range[-1]], 
                        aspect='auto', origin='lower', cmap='viridis')
    axes[0].set_xlabel('α (Coherence Strength)')
    axes[0].set_ylabel('β (Inertial Resistance)')
    axes[0].set_title('Average Coherence Phase Diagram')
    plt.colorbar(im1, ax=axes[0])
    
    # Energy stability diagram
    im2 = axes[1].imshow(energy_variance_map, extent=[alpha_range[0], alpha_range[-1], 
                                                     beta_range[0], beta_range[-1]], 
                        aspect='auto', origin='lower', cmap='plasma')
    axes[1].set_xlabel('α (Coherence Strength)')
    axes[1].set_ylabel('β (Inertial Resistance)')
    axes[1].set_title('Energy Variance (Stability)')
    plt.colorbar(im2, ax=axes[1])
    
    # Field stability diagram
    im3 = axes[2].imshow(stability_map, extent=[alpha_range[0], alpha_range[-1], 
                                               beta_range[0], beta_range[-1]], 
                        aspect='auto', origin='lower', cmap='coolwarm')
    axes[2].set_xlabel('α (Coherence Strength)')
    axes[2].set_ylabel('β (Inertial Resistance)')
    axes[2].set_title('Field Stability')
    plt.colorbar(im3, ax=axes[2])
    
    plt.tight_layout()
    
    # Find critical points
    max_coherence_idx = np.unravel_index(np.argmax(coherence_map), coherence_map.shape)
    min_energy_var_idx = np.unravel_index(np.argmin(energy_variance_map), energy_variance_map.shape)
    
    print(f"\n📊 Phase Transition Analysis Results:")
    print(f"Maximum Coherence at: α={alpha_range[max_coherence_idx[1]]:.2f}, β={beta_range[max_coherence_idx[0]]:.2f}")
    print(f"Most Stable Energy at: α={alpha_range[min_energy_var_idx[1]]:.2f}, β={beta_range[min_energy_var_idx[0]]:.2f}")
    print(f"Coherence Range: {coherence_map.min():.4f} to {coherence_map.max():.4f}")
    print(f"Energy Variance Range: {energy_variance_map.min():.6f} to {energy_variance_map.max():.6f}")
    
    return coherence_map, energy_variance_map, stability_map, alpha_range, beta_range

def advanced_cft_memory_formation_dynamics():
    """
    Simulate memory formation, consolidation, and interference.
    Models competing memories and attention-based consolidation.
    """
    print("\n🧠 Advanced Analysis: Memory Formation Dynamics")
    print("=" * 50)
    
    # Create larger simulation for memory dynamics
    sim = CoherenceFieldSimulator(width=80, height=60, dx=0.15)
    sim.alpha = 1.5  # Strong coherence
    sim.beta = 0.6   # Moderate inertia
    sim.gamma = 0.5  # Good spatial coupling
    
    # Define memory patterns
    def create_memory_pattern(center_x, center_y, strength, width=0.8):
        x_coords = sim.X - center_x
        y_coords = sim.Y - center_y
        return strength * np.exp(-(x_coords**2 + y_coords**2) / width**2)
    
    # Memory formation experiment
    memory_phases = [
        ("Encoding Phase 1", create_memory_pattern(-2, 1, 1.8, 0.6)),
        ("Encoding Phase 2", create_memory_pattern(2, -1, 1.5, 0.7)),
        ("Interference", create_memory_pattern(0, 0, 1.2, 1.0)),
        ("Consolidation", np.zeros_like(sim.X))  # No new input
    ]
    
    # Track memory evolution
    memory_strength = []
    interference_levels = []
    coherence_evolution = []
    
    fig, axes = plt.subplots(2, 4, figsize=(20, 10))
    
    for phase_idx, (phase_name, memory_input) in enumerate(memory_phases):
        print(f"  Running {phase_name}...")
        
        # Add memory input to current field
        if phase_idx < 3:  # Don't add input during consolidation
            sim.theta += 0.3 * memory_input
        
        # Run this phase
        phase_states = []
        phase_coherences = []
        
        for step in range(150):
            sim.evolve_field()
            phase_states.append(sim.theta.copy())
            phase_coherences.append(sim.total_coherence)
            
            # Measure memory strength (correlation with original patterns)
            mem1_strength = np.corrcoef(sim.theta.flatten(), 
                                       create_memory_pattern(-2, 1, 1.8, 0.6).flatten())[0,1]
            mem2_strength = np.corrcoef(sim.theta.flatten(), 
                                       create_memory_pattern(2, -1, 1.5, 0.7).flatten())[0,1]
            
            memory_strength.append([mem1_strength, mem2_strength])
            coherence_evolution.append(sim.total_coherence)
            
            # Measure interference (overlap between memory regions)
            mem1_region = create_memory_pattern(-2, 1, 1.0, 0.6) > 0.1
            mem2_region = create_memory_pattern(2, -1, 1.0, 0.7) > 0.1
            overlap = np.sum(mem1_region & mem2_region) / np.sum(mem1_region | mem2_region)
            interference_levels.append(overlap)
        
        # Plot this phase
        row = phase_idx // 4
        col = phase_idx % 4
        
        im = axes[row, col].imshow(sim.theta, cmap='RdBu_r', origin='lower', 
                                  extent=[sim.x_coords[0], sim.x_coords[-1],
                                         sim.y_coords[0], sim.y_coords[-1]])
        axes[row, col].set_title(f'{phase_name}\nCoherence: {sim.total_coherence:.3f}')
        axes[row, col].set_xlabel('x')
        axes[row, col].set_ylabel('y')
        plt.colorbar(im, ax=axes[row, col], fraction=0.046, pad=0.04)
    
    # Memory dynamics analysis
    memory_strength = np.array(memory_strength)
    coherence_evolution = np.array(coherence_evolution)
    
    # Plot memory evolution over time
    fig2, axes2 = plt.subplots(2, 2, figsize=(15, 10))
    
    time_steps = np.arange(len(memory_strength))
    
    axes2[0,0].plot(time_steps, memory_strength[:, 0], 'b-', label='Memory 1', linewidth=2)
    axes2[0,0].plot(time_steps, memory_strength[:, 1], 'r-', label='Memory 2', linewidth=2)
    axes2[0,0].axvline(150, color='gray', linestyle='--', alpha=0.7, label='Phase transitions')
    axes2[0,0].axvline(300, color='gray', linestyle='--', alpha=0.7)
    axes2[0,0].axvline(450, color='gray', linestyle='--', alpha=0.7)
    axes2[0,0].set_xlabel('Time Steps')
    axes2[0,0].set_ylabel('Memory Strength (Correlation)')
    axes2[0,0].set_title('Memory Consolidation Dynamics')
    axes2[0,0].legend()
    axes2[0,0].grid(True, alpha=0.3)
    
    axes2[0,1].plot(time_steps, coherence_evolution, 'g-', linewidth=2)
    axes2[0,1].axvline(150, color='gray', linestyle='--', alpha=0.7)
    axes2[0,1].axvline(300, color='gray', linestyle='--', alpha=0.7)
    axes2[0,1].axvline(450, color='gray', linestyle='--', alpha=0.7)
    axes2[0,1].set_xlabel('Time Steps')
    axes2[0,1].set_ylabel('System Coherence')
    axes2[0,1].set_title('Coherence During Memory Formation')
    axes2[0,1].grid(True, alpha=0.3)
    
    axes2[1,0].plot(time_steps, interference_levels, 'm-', linewidth=2)
    axes2[1,0].axvline(150, color='gray', linestyle='--', alpha=0.7)
    axes2[1,0].axvline(300, color='gray', linestyle='--', alpha=0.7)
    axes2[1,0].axvline(450, color='gray', linestyle='--', alpha=0.7)
    axes2[1,0].set_xlabel('Time Steps')
    axes2[1,0].set_ylabel('Memory Interference Level')
    axes2[1,0].set_title('Competitive Memory Dynamics')
    axes2[1,0].grid(True, alpha=0.3)
    
    # Memory strength correlation
    axes2[1,1].scatter(memory_strength[:, 0], memory_strength[:, 1], 
                      c=time_steps, cmap='viridis', alpha=0.6)
    axes2[1,1].set_xlabel('Memory 1 Strength')
    axes2[1,1].set_ylabel('Memory 2 Strength')
    axes2[1,1].set_title('Memory Competition Phase Space')
    axes2[1,1].grid(True, alpha=0.3)
    plt.colorbar(axes2[1,1].collections[0], ax=axes2[1,1], label='Time Step')
    
    plt.tight_layout()
    
    print(f"\n📊 Memory Formation Results:")
    print(f"Final Memory 1 Strength: {memory_strength[-1, 0]:.3f}")
    print(f"Final Memory 2 Strength: {memory_strength[-1, 1]:.3f}")
    print(f"Memory Interference Peak: {np.max(interference_levels):.3f}")
    print(f"Final System Coherence: {coherence_evolution[-1]:.3f}")
    
    return sim, memory_strength, coherence_evolution

def advanced_cft_traveling_wave_analysis():
    """
    Analyze traveling wave propagation, speed, and dispersion.
    Models neural information transmission dynamics.
    """
    print("\n⚡ Advanced Analysis: Neural Wave Propagation")
    print("=" * 50)
    
    # Create simulation optimized for wave dynamics
    sim = CoherenceFieldSimulator(width=120, height=40, dx=0.1)
    sim.alpha = 0.8   # Moderate coherence
    sim.beta = 1.2    # Higher inertia for wave propagation
    sim.gamma = 0.6   # Strong spatial coupling
    sim.epsilon = 0.03
    
    # Initialize traveling wave packet
    wave_center_x = -4
    wave_center_y = 0
    wave_width = 0.8
    wave_speed = 0.5
    
    # Create initial wave packet
    distance = np.sqrt((sim.X - wave_center_x)**2 + (sim.Y - wave_center_y)**2)
    sim.theta = 2.0 * np.exp(-distance**2 / wave_width**2) * np.cos(3 * sim.X)
    sim.theta_dot = wave_speed * 2.0 * np.exp(-distance**2 / wave_width**2) * np.cos(3 * sim.X)
    
    # Track wave propagation
    wave_positions = []
    wave_amplitudes = []
    wave_speeds = []
    coherence_behind_wave = []
    
    n_steps = 300
    track_interval = 5
    
    print("  Tracking wave propagation...")
    
    for step in range(n_steps):
        sim.evolve_field()
        
        if step % track_interval == 0:
            # Find wave front position (maximum gradient)
            grad_total = np.sqrt(sim.grad_x**2 + sim.grad_y**2)
            
            # Find wave center (maximum amplitude along central line)
            center_line = sim.theta[sim.height//2, :]
            max_amp_idx = np.argmax(np.abs(center_line))
            wave_x_pos = sim.x_coords[max_amp_idx]
            
            wave_positions.append(wave_x_pos)
            wave_amplitudes.append(np.max(np.abs(sim.theta)))
            
            # Calculate instantaneous wave speed
            if len(wave_positions) > 1:
                dx = wave_positions[-1] - wave_positions[-2]
                dt = track_interval * sim.dt
                speed = dx / dt
                wave_speeds.append(speed)
            else:
                wave_speeds.append(0)
            
            # Measure coherence in wake of wave
            wake_region = sim.X < (wave_x_pos - 2)
            if np.sum(wake_region) > 0:
                wake_coherence = np.mean(sim.coherence_potential[wake_region])
                coherence_behind_wave.append(wake_coherence)
            else:
                coherence_behind_wave.append(0)
    
    # Create wave analysis plots
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    
    # Final wave state
    im1 = axes[0,0].imshow(sim.theta, extent=[sim.x_coords[0], sim.x_coords[-1],
                                             sim.y_coords[0], sim.y_coords[-1]], 
                          cmap='RdBu_r', origin='lower', aspect='auto')
    axes[0,0].set_title('Final Wave State')
    axes[0,0].set_xlabel('x')
    axes[0,0].set_ylabel('y')
    plt.colorbar(im1, ax=axes[0,0])
    
    # Coherence field
    im2 = axes[0,1].imshow(sim.coherence_potential, extent=[sim.x_coords[0], sim.x_coords[-1],
                                                           sim.y_coords[0], sim.y_coords[-1]], 
                          cmap='Greens', origin='lower', aspect='auto')
    axes[0,1].set_title('Coherence Wells in Wave Wake')
    axes[0,1].set_xlabel('x')
    axes[0,1].set_ylabel('y')
    plt.colorbar(im2, ax=axes[0,1])
    
    # Wave position tracking
    time_points = np.array(range(len(wave_positions))) * track_interval * sim.dt
    axes[0,2].plot(time_points, wave_positions, 'b-', linewidth=2, marker='o', markersize=3)
    axes[0,2].set_xlabel('Time')
    axes[0,2].set_ylabel('Wave Position')
    axes[0,2].set_title('Wave Propagation')
    axes[0,2].grid(True, alpha=0.3)
    
    # Linear fit for average speed
    if len(time_points) > 1:
        slope, intercept = np.polyfit(time_points, wave_positions, 1)
        axes[0,2].plot(time_points, slope * time_points + intercept, 'r--', 
                      label=f'Avg Speed: {slope:.3f}')
        axes[0,2].legend()
    
    # Wave amplitude decay
    axes[1,0].plot(time_points, wave_amplitudes, 'r-', linewidth=2)
    axes[1,0].set_xlabel('Time')
    axes[1,0].set_ylabel('Wave Amplitude')
    axes[1,0].set_title('Wave Amplitude Decay')
    axes[1,0].grid(True, alpha=0.3)
    
    # Instantaneous wave speed
    if len(wave_speeds) > 1:
        axes[1,1].plot(time_points[1:], wave_speeds[1:], 'g-', linewidth=2)
        axes[1,1].set_xlabel('Time')
        axes[1,1].set_ylabel('Instantaneous Speed')
        axes[1,1].set_title('Wave Speed Variation')
        axes[1,1].grid(True, alpha=0.3)
    
    # Coherence in wave wake
    axes[1,2].plot(time_points, coherence_behind_wave, 'm-', linewidth=2)
    axes[1,2].set_xlabel('Time')
    axes[1,2].set_ylabel('Wake Coherence')
    axes[1,2].set_title('Coherence Behind Wave')
    axes[1,2].grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Analysis results
    avg_speed = np.mean(wave_speeds[10:]) if len(wave_speeds) > 10 else np.mean(wave_speeds)
    final_amplitude = wave_amplitudes[-1]
    initial_amplitude = wave_amplitudes[0]
    amplitude_decay = (initial_amplitude - final_amplitude) / initial_amplitude
    
    print(f"\n📊 Wave Propagation Results:")
    print(f"Average Wave Speed: {avg_speed:.4f}")
    print(f"Initial Amplitude: {initial_amplitude:.3f}")
    print(f"Final Amplitude: {final_amplitude:.3f}")
    print(f"Amplitude Decay: {amplitude_decay*100:.1f}%")
    print(f"Distance Traveled: {wave_positions[-1] - wave_positions[0]:.2f}")
    print(f"Average Wake Coherence: {np.mean(coherence_behind_wave):.4f}")
    
    return sim, wave_positions, wave_amplitudes, wave_speeds

def advanced_cft_bifurcation_analysis():
    """
    Analyze bifurcation points and critical phenomena in CFT parameter space.
    Identifies where system behavior qualitatively changes.
    """
    print("\n🌊 Advanced Analysis: Bifurcation and Critical Points")
    print("=" * 50)
    
    # Focus on critical alpha values where coherence wells form/disappear
    alpha_values = np.linspace(0.1, 2.5, 50)
    
    # Metrics to detect bifurcations
    steady_state_variance = []
    max_coherence_values = []
    pattern_complexity = []
    
    print("  Scanning parameter space for bifurcations...")
    
    for i, alpha in enumerate(alpha_values):
        sim = CoherenceFieldSimulator(width=40, height=40)
        sim.alpha = alpha
        sim.beta = 0.8
        sim.gamma = 0.4
        sim.epsilon = 0.05
        
        # Start with small random perturbation
        sim.theta = 0.1 * (np.random.random((sim.height, sim.width)) - 0.5)
        
        # Let system reach steady state
        for _ in range(300):
            sim.evolve_field()
        
        # Analyze steady state
        final_states = []
        coherence_values = []
        
        for _ in range(50):
            sim.evolve_field()
            final_states.append(sim.theta.copy())
            coherence_values.append(sim.max_coherence)
        
        # Compute metrics
        steady_state_variance.append(np.var([np.var(state) for state in final_states]))
        max_coherence_values.append(np.max(coherence_values))
        
        # Pattern complexity (number of local maxima)
        final_theta = final_states[-1]
        from scipy import ndimage
        local_max = ndimage.maximum_filter(final_theta, size=3) == final_theta
        complexity = np.sum(local_max & (final_theta > 0.1))
        pattern_complexity.append(complexity)
        
        if i % 10 == 0:
            print(f"    Progress: {i/len(alpha_values)*100:.0f}%")
    
    # Detect bifurcation points
    # Look for sudden changes in derivatives
    variance_derivative = np.gradient(steady_state_variance)
    coherence_derivative = np.gradient(max_coherence_values)
    complexity_derivative = np.gradient(pattern_complexity)
    
    # Find peaks in derivatives (bifurcation candidates)
    from scipy.signal import find_peaks
    
    variance_peaks, _ = find_peaks(np.abs(variance_derivative), height=np.std(variance_derivative))
    coherence_peaks, _ = find_peaks(np.abs(coherence_derivative), height=np.std(coherence_derivative))
    
    # Plot bifurcation analysis
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # Steady state variance
    axes[0,0].plot(alpha_values, steady_state_variance, 'b-', linewidth=2)
    for peak in variance_peaks:
        axes[0,0].axvline(alpha_values[peak], color='red', linestyle='--', alpha=0.7)
    axes[0,0].set_xlabel('α (Coherence Strength)')
    axes[0,0].set_ylabel('Steady State Variance')
    axes[0,0].set_title('System Stability vs α')
    axes[0,0].grid(True, alpha=0.3)
    
    # Maximum coherence
    axes[0,1].plot(alpha_values, max_coherence_values, 'g-', linewidth=2)
    for peak in coherence_peaks:
        axes[0,1].axvline(alpha_values[peak], color='red', linestyle='--', alpha=0.7)
    axes[0,1].set_xlabel('α (Coherence Strength)')
    axes[0,1].set_ylabel('Maximum Coherence')
    axes[0,1].set_title('Coherence Wells vs α')
    axes[0,1].grid(True, alpha=0.3)
    
    # Pattern complexity
    axes[1,0].plot(alpha_values, pattern_complexity, 'm-', linewidth=2)
    axes[1,0].set_xlabel('α (Coherence Strength)')
    axes[1,0].set_ylabel('Pattern Complexity')
    axes[1,0].set_title('Spatial Pattern Complexity')
    axes[1,0].grid(True, alpha=0.3)
    
    # Phase portrait (variance vs coherence)
    scatter = axes[1,1].scatter(max_coherence_values, steady_state_variance, 
                               c=alpha_values, cmap='viridis', alpha=0.7)
    axes[1,1].set_xlabel('Maximum Coherence')
    axes[1,1].set_ylabel('Steady State Variance')
    axes[1,1].set_title('Phase Portrait')
    plt.colorbar(scatter, ax=axes[1,1], label='α value')
    
    plt.tight_layout()
    
    # Identify critical points
    if len(variance_peaks) > 0:
        critical_alphas = alpha_values[variance_peaks]
        print(f"\n📊 Bifurcation Analysis Results:")
        print(f"Critical α values (bifurcation points): {critical_alphas}")
        
        for i, alpha_c in enumerate(critical_alphas):
            print(f"  Bifurcation {i+1}: α = {alpha_c:.3f}")
            
    else:
        print(f"\nNo clear bifurcation points detected in range α ∈ [{alpha_values[0]:.1f}, {alpha_values[-1]:.1f}]")
    
    return alpha_values, steady_state_variance, max_coherence_values, pattern_complexity

def run_all_advanced_tests():
    """Run all advanced CFT tests in sequence"""
    print("🚀 Running Complete Advanced CFT Analysis Suite")
    print("=" * 60)
    
    try:
        # Test 1: Phase transitions
        coherence_map, energy_map, stability_map, alpha_range, beta_range = advanced_cft_phase_transition_analysis()
        plt.show()
        
        # Test 2: Memory dynamics
        memory_sim, memory_strength, coherence_evolution = advanced_cft_memory_formation_dynamics()
        plt.show()
        
        # Test 3: Wave propagation
        wave_sim, positions, amplitudes, speeds = advanced_cft_traveling_wave_analysis()
        plt.show()
        
        # Test 4: Bifurcations
        alphas, variances, coherences, complexity = advanced_cft_bifurcation_analysis()
        plt.show()
        
        print("\n🎉 All advanced tests completed successfully!")
        print("=" * 60)
        
        return {
            'phase_transition': (coherence_map, energy_map, stability_map),
            'memory_dynamics': (memory_sim, memory_strength, coherence_evolution),
            'wave_propagation': (wave_sim, positions, amplitudes, speeds),
            'bifurcation': (alphas, variances, coherences, complexity)
        }
        
    except Exception as e:
        print(f"❌ Error in advanced tests: {e}")
        import traceback
        traceback.print_exc()
        return None

# Quick test - run this first to check if everything works:
# test_cft_basic()

# For advanced analysis, run:
# results = run_all_advanced_tests()
