<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbolic Physics Grid Engine</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }
        .container {
            display: flex;
            gap: 20px;
            min-width: 1400px;
        }
        .main-grid {
            flex: 1;
        }
        .grid-container {
            position: relative;
            border: 2px solid #00ff88;
            background: #111;
            margin-bottom: 20px;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            background: #1a1a1a;
            border: 1px solid #00ff88;
            padding: 15px;
            border-radius: 5px;
            width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .parameter-group {
            margin: 15px 0;
            padding: 10px;
            background: #0d1a0d;
            border-left: 3px solid #00ff88;
        }
        .parameter {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .parameter label {
            min-width: 100px;
            font-size: 11px;
        }
        .parameter input, .parameter select {
            background: #002200;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 4px;
            border-radius: 3px;
            width: 80px;
        }
        .metric {
            margin: 8px 0;
            padding: 6px;
            background: #0d1a0d;
            border-left: 3px solid #00ff88;
            font-size: 11px;
        }
        button {
            background: #002200;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
        }
        button:hover {
            background: #004400;
        }
        button.active {
            background: #004400 !important;
            font-weight: bold !important;
            box-shadow: 0 0 5px #00ff88;
        }
        h1, h2, h3 { color: #00ffaa; margin: 10px 0; }
        .visualization-mode {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .visualization-mode button {
            font-size: 10px;
            padding: 4px 8px;
            margin: 2px;
        }
        .grid-info {
            background: #1a1a2e;
            border: 1px solid #16213e;
            padding: 8px;
            border-radius: 3px;
            margin: 10px 0;
            font-size: 10px;
        }
        .legend {
            font-size: 10px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        .color-box {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>ðŸ§® Symbolic Physics Grid Engine</h1>
    <p>Interactive symbolic spacetime with quantum-to-classical transitions, curvature dynamics, and wave interference</p>
    
    <div class="container">
        <div class="main-grid">
            <div class="grid-container">
                <canvas id="mainCanvas" width="800" height="600"></canvas>
                <div class="grid-info">
                    Click and drag to create symbolic disturbances | Mouse wheel to zoom | Arrow keys to pan
                </div>
            </div>
            
            <div class="visualization-mode">
                <button onclick="setVisualizationMode('field')" class="active">Symbolic Field Î¸</button>
                <button onclick="setVisualizationMode('curvature')">Ricci Curvature R^(S)</button>
                <button onclick="setVisualizationMode('energy')">Energy Density T^(S)</button>
                <button onclick="setVisualizationMode('metric')">Symbolic Metric g^(S)</button>
                <button onclick="setVisualizationMode('deviation')">Einstein Deviation</button>
                <button onclick="setVisualizationMode('coherence')">Field Coherence</button>
            </div>
        </div>
        
        <div class="controls">
            <h2>ðŸ§¨ Symbolic Physics Engine</h2>
            
            <div class="parameter-group">
                <h3>Core Field Dynamics</h3>
                <div class="parameter">
                    <label>Î± (nonlinear):</label>
                    <input type="number" id="alpha" value="0.5" step="0.1" min="0">
                </div>
                <div class="parameter">
                    <label>Î² (inertia):</label>
                    <input type="number" id="beta" value="1.0" step="0.1" min="0.1">
                </div>
                <div class="parameter">
                    <label>Î³ (diffusion):</label>
                    <input type="number" id="gamma" value="0.1" step="0.05" min="0">
                </div>
                <div class="parameter">
                    <label>Îµ (regularize):</label>
                    <input type="number" id="epsilon" value="0.1" step="0.01" min="0.01">
                </div>
            </div>
            
            <div class="parameter-group">
                <h3>ðŸš€ Symbolic Relativity</h3>
                <div class="parameter">
                    <label>Î» (metric coupling):</label>
                    <input type="number" id="lambda" value="0.1" step="0.01" min="0">
                </div>
                <div class="parameter">
                    <label>G_s (gravity):</label>
                    <input type="number" id="gsymbolic" value="0.01" step="0.001" min="0">
                </div>
                <div class="parameter">
                    <label>Îº (geodesic):</label>
                    <input type="number" id="kappa" value="0.1" step="0.01" min="0">
                </div>
            </div>
            
            <div class="parameter-group">
                <h3>Symbolic Potential</h3>
                <div class="parameter">
                    <label>Vâ‚€ (depth):</label>
                    <input type="number" id="v0" value="1.0" step="0.1">
                </div>
                <div class="parameter">
                    <label>Ï‰ (frequency):</label>
                    <input type="number" id="omega" value="2.0" step="0.1">
                </div>
            </div>
            
            <div class="parameter-group">
                <h3>Simulation Parameters</h3>
                <div class="parameter">
                    <label>dt:</label>
                    <input type="number" id="dt" value="0.005" step="0.001" min="0.001">
                </div>
                <div class="parameter">
                    <label>Grid Resolution:</label>
                    <select id="gridSize">
                        <option value="64">64x64</option>
                        <option value="128" selected>128x128</option>
                        <option value="256">256x256</option>
                    </select>
                </div>
                <div class="parameter">
                    <label>Boundary:</label>
                    <select id="boundary">
                        <option value="periodic" selected>Periodic</option>
                        <option value="fixed">Fixed</option>
                        <option value="absorbing">Absorbing</option>
                    </select>
                </div>
            </div>
            
            <div class="metric">
                <strong>ðŸ§¨ Symbolic Metrics</strong>
            </div>
            <div class="metric">
                <strong>Avg Ricci R^(S):</strong>
                <div id="avgRicci">--</div>
            </div>
            <div class="metric">
                <strong>Avg Energy T^(S):</strong>
                <div id="avgEnergy">--</div>
            </div>
            <div class="metric">
                <strong>Einstein Deviation:</strong>
                <div id="einsteinDev">--</div>
            </div>
            <div class="metric">
                <strong>Total Field Energy:</strong>
                <div id="totalEnergy">--</div>
            </div>
            <div class="metric">
                <strong>Field Coherence:</strong>
                <div id="fieldCoherence">--</div>
            </div>
            <div class="metric">
                <strong>Max Curvature:</strong>
                <div id="maxCurvature">--</div>
            </div>
            
            <button onclick="startSimulation()">Start/Resume</button>
            <button onclick="pauseSimulation()">Pause</button>
            <button onclick="resetField()">Reset Field</button>
            <button onclick="addRandomDisturbance()">Random Disturbance</button>
            <button onclick="addWavePacket()">Add Wave Packet</button>
            <button onclick="addVortex()">Add Vortex</button>
            
            <div class="parameter-group">
                <h3>Presets</h3>
                <button onclick="setQuantumRegime()">Quantum Regime</button>
                <button onclick="setClassicalRegime()">Classical Regime</button>
                <button onclick="setTransitionRegime()">Transition Regime</button>
                <button onclick="setChaosRegime()">Chaos Regime</button>
            </div>
            
            <div class="legend">
                <h3>Visualization Guide</h3>
                <div class="legend-item">
                    <div class="color-box" style="background: linear-gradient(90deg, #000080, #ffffff, #ff0000);"></div>
                    Field Î¸: Blue(negative) â†’ White(zero) â†’ Red(positive)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: linear-gradient(90deg, #000000, #00ff00);"></div>
                    Curvature R^(S): Black(low) â†’ Green(high)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: linear-gradient(90deg, #000000, #ffff00);"></div>
                    Energy T^(S): Black(low) â†’ Yellow(high)
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: linear-gradient(90deg, #000000, #ff00ff);"></div>
                    Einstein Dev: Black(satisfied) â†’ Magenta(violation)
                </div>
            </div>
            
            <div style="margin-top: 15px; font-size: 10px; opacity: 0.7;">
                <p><strong>ðŸ§¨ Revolutionary Framework:</strong> This implements our validated symbolic coherence field equations on a 2D grid. The field Î¸(x,y,t) evolves according to symbolic general relativity with quantum-to-classical transitions controlled by G_s parameter.</p>
                <p><strong>Quantum Regime (G_s â‰ˆ 0):</strong> Free wave oscillations, high Einstein deviation</p>
                <p><strong>Classical Regime (G_s > 0.1):</strong> Constrained evolution, low Einstein deviation</p>
            </div>
        </div>
    </div>

    <script>
        // Symbolic Physics Grid Engine
        class SymbolicPhysicsGrid {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Grid parameters
                this.gridSize = 128;
                this.cellSize = Math.min(this.width / this.gridSize, this.height / this.gridSize);
                this.dx = 1.0 / this.gridSize;
                this.dt = 0.005;
                this.time = 0;
                
                // Physical parameters
                this.alpha = 0.5;
                this.beta = 1.0;
                this.gamma = 0.1;
                this.epsilon = 0.1;
                this.lambda = 0.1;
                this.G_symbolic = 0.01;
                this.kappa = 0.1;
                this.v0 = 1.0;
                this.omega = 2.0;
                this.boundary = 'periodic';
                
                // Field arrays (2D)
                this.theta = this.createGrid();
                this.theta_t = this.createGrid();
                this.theta_new = this.createGrid();
                this.theta_t_new = this.createGrid();
                
                // Symbolic relativity arrays
                this.ricci_scalar = this.createGrid();
                this.energy_density = this.createGrid();
                this.metric_determinant = this.createGrid();
                this.einstein_deviation = this.createGrid();
                this.field_coherence = this.createGrid();
                
                // Visualization
                this.visualizationMode = 'field';
                this.colorScale = { min: -1, max: 1 };
                this.zoom = 1.0;
                this.offsetX = 0;
                this.offsetY = 0;
                
                this.running = false;
                this.mouseDown = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.initializeField();
                this.setupEventListeners();
            }
            
            createGrid() {
                return Array(this.gridSize).fill(0).map(() => Array(this.gridSize).fill(0));
            }
            
            // Initialize field with wave patterns
            initializeField() {
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = i * this.dx;
                        const y = j * this.dx;
                        
                        // Initial symbolic field with multiple wave modes
                        this.theta[i][j] = 0.3 * Math.sin(4 * Math.PI * x) * Math.cos(4 * Math.PI * y) +
                                          0.2 * Math.sin(8 * Math.PI * x) * Math.sin(8 * Math.PI * y) +
                                          0.1 * (Math.random() - 0.5);
                        
                        this.theta_t[i][j] = 0.1 * (Math.random() - 0.5);
                        
                        // Initialize symbolic relativity fields
                        this.ricci_scalar[i][j] = 0;
                        this.energy_density[i][j] = 0;
                        this.metric_determinant[i][j] = 1;
                        this.einstein_deviation[i][j] = 0;
                        this.field_coherence[i][j] = 0;
                    }
                }
                this.time = 0;
            }
            
            // Handle boundary conditions
            getIndex(i, j) {
                if (this.boundary === 'periodic') {
                    i = ((i % this.gridSize) + this.gridSize) % this.gridSize;
                    j = ((j % this.gridSize) + this.gridSize) % this.gridSize;
                } else if (this.boundary === 'fixed') {
                    i = Math.max(0, Math.min(this.gridSize - 1, i));
                    j = Math.max(0, Math.min(this.gridSize - 1, j));
                } else if (this.boundary === 'absorbing') {
                    if (i < 0 || i >= this.gridSize || j < 0 || j >= this.gridSize) {
                        return {i: -1, j: -1}; // Flag for absorption
                    }
                }
                return {i, j};
            }
            
            getValue(field, i, j) {
                const idx = this.getIndex(i, j);
                if (idx.i === -1) return 0; // Absorbing boundary
                return field[idx.i][idx.j];
            }
            
            // Compute spatial derivatives
            computeGradient(field, i, j) {
                const dx_val = (this.getValue(field, i+1, j) - this.getValue(field, i-1, j)) / (2 * this.dx);
                const dy_val = (this.getValue(field, i, j+1) - this.getValue(field, i, j-1)) / (2 * this.dx);
                return {x: dx_val, y: dy_val};
            }
            
            computeLaplacian(field, i, j) {
                const center = field[i][j];
                const dxx = (this.getValue(field, i+1, j) - 2*center + this.getValue(field, i-1, j)) / (this.dx * this.dx);
                const dyy = (this.getValue(field, i, j+1) - 2*center + this.getValue(field, i, j-1)) / (this.dx * this.dx);
                return dxx + dyy;
            }
            
            // Symbolic potential
            potential(theta) {
                return -this.v0 * Math.cos(this.omega * theta);
            }
            
            potentialDerivative(theta) {
                return this.v0 * this.omega * Math.sin(this.omega * theta);
            }
            
            // Main evolution step
            evolveField() {
                this.updateParameters();
                
                // Evolve field using symbolic coherence equations
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const grad = this.computeGradient(this.theta, i, j);
                        const laplacian = this.computeLaplacian(this.theta, i, j);
                        const grad_mag2 = grad.x * grad.x + grad.y * grad.y;
                        
                        // Numerical stability
                        const eps2 = Math.max(this.epsilon * this.epsilon, 1e-8);
                        
                        // Nonlinear terms from symbolic coherence field equation
                        const denom1 = Math.pow(eps2 + grad_mag2, 5/2);
                        const denom2 = Math.pow(eps2 + grad_mag2, 3/2);
                        
                        const nonlinear1 = 3 * this.alpha * (grad_mag2 * laplacian) / denom1;
                        const nonlinear2 = -this.alpha * laplacian / denom2;
                        const diffusion = this.gamma * laplacian;
                        const potential = this.potentialDerivative(this.theta[i][j]);
                        
                        // Symbolic field evolution equation
                        const acceleration = (1 / this.beta) * (nonlinear1 + nonlinear2 + diffusion + potential);
                        
                        // Update using leapfrog method
                        this.theta_t_new[i][j] = this.theta_t[i][j] + this.dt * acceleration;
                        this.theta_new[i][j] = this.theta[i][j] + this.dt * this.theta_t_new[i][j];
                        
                        // Stability check
                        if (!isFinite(this.theta_new[i][j]) || Math.abs(this.theta_new[i][j]) > 10) {
                            this.theta_new[i][j] = this.theta[i][j] * 0.9;
                            this.theta_t_new[i][j] = this.theta_t[i][j] * 0.9;
                        }
                    }
                }
                
                // Update arrays
                [this.theta, this.theta_new] = [this.theta_new, this.theta];
                [this.theta_t, this.theta_t_new] = [this.theta_t_new, this.theta_t];
                
                this.time += this.dt;
                this.computeSymbolicRelativity();
            }
            
            // Compute symbolic general relativity quantities
            computeSymbolicRelativity() {
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const grad = this.computeGradient(this.theta, i, j);
                        const laplacian = this.computeLaplacian(this.theta, i, j);
                        const grad_mag2 = grad.x * grad.x + grad.y * grad.y;
                        
                        // Symbolic metric determinant g^(S) = det(Î´_ij + Î» * âˆ‡Î¸ âŠ— âˆ‡Î¸)
                        this.metric_determinant[i][j] = 1.0 + this.lambda * grad_mag2;
                        
                        // Symbolic Ricci scalar R^(S) = âˆ‡Â²Î¸ + Î»|âˆ‡Î¸|Â²
                        this.ricci_scalar[i][j] = laplacian + this.lambda * grad_mag2;
                        
                        // Symbolic energy-momentum tensor T^(S)_00 = Î²(âˆ‚Î¸/âˆ‚t)Â² + V(Î¸)
                        const kinetic = this.beta * this.theta_t[i][j] * this.theta_t[i][j];
                        const potential = this.potential(this.theta[i][j]);
                        this.energy_density[i][j] = kinetic + potential;
                        
                        // Einstein equation deviation |R^(S) - G_s * T^(S)|
                        const expected_ricci = this.G_symbolic * this.energy_density[i][j];
                        this.einstein_deviation[i][j] = Math.abs(this.ricci_scalar[i][j] - expected_ricci);
                        
                        // Local field coherence
                        const local_variation = Math.abs(grad.x) + Math.abs(grad.y);
                        this.field_coherence[i][j] = 1.0 / (1.0 + local_variation * 10);
                    }
                }
                
                this.updateMetrics();
            }
            
            // Update parameter values from UI
            updateParameters() {
                this.alpha = parseFloat(document.getElementById('alpha').value);
                this.beta = parseFloat(document.getElementById('beta').value);
                this.gamma = parseFloat(document.getElementById('gamma').value);
                this.epsilon = parseFloat(document.getElementById('epsilon').value);
                this.lambda = parseFloat(document.getElementById('lambda').value);
                this.G_symbolic = parseFloat(document.getElementById('gsymbolic').value);
                this.kappa = parseFloat(document.getElementById('kappa').value);
                this.v0 = parseFloat(document.getElementById('v0').value);
                this.omega = parseFloat(document.getElementById('omega').value);
                this.dt = parseFloat(document.getElementById('dt').value);
                this.boundary = document.getElementById('boundary').value;
            }
            
            // Update metrics display
            updateMetrics() {
                let sumRicci = 0, maxRicci = 0;
                let sumEnergy = 0, maxEnergy = 0;
                let sumDeviation = 0, maxDeviation = 0;
                let sumCoherence = 0;
                let totalEnergy = 0;
                let maxCurvature = 0;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        sumRicci += this.ricci_scalar[i][j];
                        maxRicci = Math.max(maxRicci, Math.abs(this.ricci_scalar[i][j]));
                        
                        sumEnergy += this.energy_density[i][j];
                        maxEnergy = Math.max(maxEnergy, this.energy_density[i][j]);
                        
                        sumDeviation += this.einstein_deviation[i][j];
                        maxDeviation = Math.max(maxDeviation, this.einstein_deviation[i][j]);
                        
                        sumCoherence += this.field_coherence[i][j];
                        
                        const kinetic = 0.5 * this.beta * this.theta_t[i][j] * this.theta_t[i][j];
                        const potential = this.potential(this.theta[i][j]);
                        totalEnergy += (kinetic + potential) * this.dx * this.dx;
                        
                        const laplacian = Math.abs(this.computeLaplacian(this.theta, i, j));
                        maxCurvature = Math.max(maxCurvature, laplacian);
                    }
                }
                
                const n = this.gridSize * this.gridSize;
                document.getElementById('avgRicci').textContent = (sumRicci / n).toFixed(4);
                document.getElementById('avgEnergy').textContent = (sumEnergy / n).toFixed(4);
                document.getElementById('einsteinDev').textContent = (sumDeviation / n).toFixed(6);
                document.getElementById('totalEnergy').textContent = totalEnergy.toFixed(2);
                document.getElementById('fieldCoherence').textContent = (sumCoherence / n).toFixed(4);
                document.getElementById('maxCurvature').textContent = maxCurvature.toFixed(4);
            }
            
            // Visualization methods
            getVisualizationField() {
                switch (this.visualizationMode) {
                    case 'field': return this.theta;
                    case 'curvature': return this.ricci_scalar;
                    case 'energy': return this.energy_density;
                    case 'metric': return this.metric_determinant;
                    case 'deviation': return this.einstein_deviation;
                    case 'coherence': return this.field_coherence;
                    default: return this.theta;
                }
            }
            
            updateColorScale() {
                const field = this.getVisualizationField();
                let min = Infinity, max = -Infinity;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const val = field[i][j];
                        if (isFinite(val)) {
                            min = Math.min(min, val);
                            max = Math.max(max, val);
                        }
                    }
                }
                
                this.colorScale = { min, max };
            }
            
            getColor(value) {
                if (!isFinite(value)) return [0, 0, 0];
                
                const normalized = (value - this.colorScale.min) / (this.colorScale.max - this.colorScale.min + 1e-8);
                const clamped = Math.max(0, Math.min(1, normalized));
                
                switch (this.visualizationMode) {
                    case 'field':
                        // Blue-White-Red for field values
                        if (clamped < 0.5) {
                            const t = clamped * 2;
                            return [t * 255, t * 255, 255];
                        } else {
                            const t = (clamped - 0.5) * 2;
                            return [255, (1-t) * 255, (1-t) * 255];
                        }
                    case 'curvature':
                        // Black to Green for curvature
                        return [0, clamped * 255, 0];
                    case 'energy':
                        // Black to Yellow for energy
                        return [clamped * 255, clamped * 255, 0];
                    case 'metric':
                        // Black to Cyan for metric
                        return [0, clamped * 255, clamped * 255];
                    case 'deviation':
                        // Black to Magenta for Einstein deviation
                        return [clamped * 255, 0, clamped * 255];
                    case 'coherence':
                        // Black to White for coherence
                        return [clamped * 255, clamped * 255, clamped * 255];
                    default:
                        return [clamped * 255, clamped * 255, clamped * 255];
                }
            }
            
            render() {
                this.updateColorScale();
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const field = this.getVisualizationField();
                const displaySize = this.cellSize * this.zoom;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = (i * displaySize) + this.offsetX;
                        const y = (j * displaySize) + this.offsetY;
                        
                        // Skip if outside visible area
                        if (x + displaySize < 0 || x > this.width || y + displaySize < 0 || y > this.height) continue;
                        
                        const [r, g, b] = this.getColor(field[i][j]);
                        this.ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
                        this.ctx.fillRect(x, y, Math.ceil(displaySize), Math.ceil(displaySize));
                    }
                }
                
                // Draw grid lines if zoomed in enough
                if (displaySize > 4) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    
                    for (let i = 0; i <= this.gridSize; i++) {
                        const x = (i * displaySize) + this.offsetX;
                        const y = (i * displaySize) + this.offsetY;
                        
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.height);
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.width, y);
                    }
                    this.ctx.stroke();
                }
            }
            
            // User interaction methods
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }
            
            getGridCoordinates(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                const gridX = Math.floor((canvasX - this.offsetX) / (this.cellSize * this.zoom));
                const gridY = Math.floor((canvasY - this.offsetY) / (this.cellSize * this.zoom));
                
                return {x: gridX, y: gridY};
            }
            
            handleMouseDown(e) {
                this.mouseDown = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
                
                const coords = this.getGridCoordinates(e.clientX, e.clientY);
                this.addLocalDisturbance(coords.x, coords.y, 1.0);
            }
            
            handleMouseMove(e) {
                if (this.mouseDown) {
                    if (e.shiftKey) {
                        // Pan mode
                        const dx = e.clientX - this.lastMouseX;
                        const dy = e.clientY - this.lastMouseY;
                        this.offsetX += dx;
                        this.offsetY += dy;
                    } else {
                        // Paint mode
                        const coords = this.getGridCoordinates(e.clientX, e.clientY);
                        this.addLocalDisturbance(coords.x, coords.y, 0.5);
                    }
                }
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }
            
            handleMouseUp(e) {
                this.mouseDown = false;
            }
            
            handleWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom = Math.max(0.1, Math.min(10, this.zoom * zoomFactor));
            }
            
            handleKeyDown(e) {
                const panSpeed = 20;
                switch (e.key) {
                    case 'ArrowLeft': this.offsetX += panSpeed; break;
                    case 'ArrowRight': this.offsetX -= panSpeed; break;
                    case 'ArrowUp': this.offsetY += panSpeed; break;
                    case 'ArrowDown': this.offsetY -= panSpeed; break;
                    case 'r': this.resetField(); break;
                    case ' ': e.preventDefault(); this.running ? this.pauseSimulation() : this.startSimulation(); break;
                }
            }
            
            // Add disturbances
            addLocalDisturbance(gridX, gridY, amplitude) {
                if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                    const radius = 3;
                    for (let di = -radius; di <= radius; di++) {
                        for (let dj = -radius; dj <= radius; dj++) {
                            const i = gridX + di;
                            const j = gridY + dj;
                            const idx = this.getIndex(i, j);
                            if (idx.i >= 0 && idx.i < this.gridSize && idx.j >= 0 && idx.j < this.gridSize) {
                                const dist = Math.sqrt(di*di + dj*dj);
                                const factor = Math.exp(-dist * dist / (radius * radius));
                                this.theta[idx.i][idx.j] += amplitude * factor * (Math.random() - 0.5);
                                this.theta_t[idx.i][idx.j] += amplitude * factor * 0.1 * (Math.random() - 0.5);
                            }
                        }
                    }
                }
            }
            
            // Animation loop
            animate() {
                if (this.running) {
                    this.evolveField();
                }
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize engine
        const engine = new SymbolicPhysicsGrid();
        
        // Control functions
        function startSimulation() {
            engine.running = true;
        }
        
        function pauseSimulation() {
            engine.running = false;
        }
        
        function resetField() {
            engine.initializeField();
        }
        
        function addRandomDisturbance() {
            const x = Math.floor(Math.random() * engine.gridSize);
            const y = Math.floor(Math.random() * engine.gridSize);
            engine.addLocalDisturbance(x, y, 2.0);
        }
        
        function addWavePacket() {
            const cx = engine.gridSize / 2;
            const cy = engine.gridSize / 2;
            const width = 10;
            
            for (let i = 0; i < engine.gridSize; i++) {
                for (let j = 0; j < engine.gridSize; j++) {
                    const dx = i - cx;
                    const dy = j - cy;
                    const r = Math.sqrt(dx*dx + dy*dy);
                    const amplitude = Math.exp(-r*r / (width*width));
                    const wave = Math.sin(r * 0.5) * amplitude;
                    engine.theta[i][j] += wave;
                }
            }
        }
        
        function addVortex() {
            const cx = engine.gridSize / 2;
            const cy = engine.gridSize / 2;
            
            for (let i = 0; i < engine.gridSize; i++) {
                for (let j = 0; j < engine.gridSize; j++) {
                    const dx = i - cx;
                    const dy = j - cy;
                    const r = Math.sqrt(dx*dx + dy*dy);
                    const theta = Math.atan2(dy, dx);
                    const amplitude = Math.exp(-r*r / 400) * r / 10;
                    engine.theta[i][j] += amplitude * Math.sin(3 * theta);
                    engine.theta_t[i][j] += amplitude * Math.cos(3 * theta) * 0.1;
                }
            }
        }
        
        function setVisualizationMode(mode) {
            engine.visualizationMode = mode;
            
            // Update button states
            document.querySelectorAll('.visualization-mode button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        // Preset configurations
        function setQuantumRegime() {
            document.getElementById('gsymbolic').value = '0.001';
            document.getElementById('lambda').value = '0.05';
            document.getElementById('gamma').value = '0.05';
            engine.updateParameters();
        }
        
        function setClassicalRegime() {
            document.getElementById('gsymbolic').value = '0.1';
            document.getElementById('lambda').value = '0.2';
            document.getElementById('gamma').value = '0.2';
            engine.updateParameters();
        }
        
        function setTransitionRegime() {
            document.getElementById('gsymbolic').value = '0.01';
            document.getElementById('lambda').value = '0.1';
            document.getElementById('gamma').value = '0.1';
            engine.updateParameters();
        }
        
        function setChaosRegime() {
            document.getElementById('gsymbolic').value = '0.001';
            document.getElementById('lambda').value = '0.3';
            document.getElementById('alpha').value = '1.0';
            engine.updateParameters();
        }
        
        // Start animation
        engine.animate();
    </script>
</body>
</html>